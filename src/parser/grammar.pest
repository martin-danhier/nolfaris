// Define whitespace and comment. These will be skipped.
WHITESPACE = _{ " " | "\r\n" | "\n" | "\r" }
COMMENT = _{
    ("//" ~ ( !"\n" ~ ANY)* ~ ("\n" | EOI))
    | ("/*" ~ (!"*/" ~ ANY)* ~ "*/" )
}

// == Global rule ==

file = { SOI ~ statement* ~ EOI }

// =================
// == Expressions ==
// =================

expression = { binary_operation }

binary_operation = { unary_operation ~ (binary_operator ~ unary_operation)* }

unary_operation = {
    (prefix_operator)? ~ term ~ (postfix_operator)?
}

term = {float | integer | bool | char | raw_string | string | identifier  | indexing | "(" ~ expression ~ ")"}


// == Literals ==

// Integers
dec_integer = @{ ASCII_DIGIT+ }
hex_integer = @{ ASCII_HEX_DIGIT+ }
bin_integer = @{ ASCII_BIN_DIGIT+ }
integer = ${ "0x" ~ hex_integer | "0b" ~ bin_integer | dec_integer }

// Floats
float = @{ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }

// Booleans
bool = { "true" | "false" }

// Char

character = @{
    // Normal character
    !("\"" | "\\") ~ ANY
    // Escape sequence
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    // Unicode escape sequence
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}

char = ${ "'" ~ character ~ "'" }

// Strings

inner_string = ${ character* }

string = ${ "\"" ~ inner_string ~ "\"" }

inner_raw_string = @{ (!("\"" ~ PEEK) ~ ANY)* }

raw_string = ${ "r" ~ PUSH("#"*) ~ "\"" ~ inner_raw_string ~  "\"" ~ POP }

// Function call

expression_list = {
    expression ~ ("," ~ expression)*
}

// == Operators ==

// Binary
plus = { "+" }
times = { "*" }
minus = { "-" }
div = { "/" }
exponent = { "**" }
modulo = { "%" }
or = { "or" }
and = { "and" }
less_or_equal_to = { "<=" }
greater_or_equal_to = { ">=" }
less_than = { "<" }
greater_than = { ">" }
equals = { "==" }
different = { "!=" }
nav = { "." }


binary_operator = _{
    exponent
    | times
    | div
    | modulo
    | plus
    | minus
    | less_or_equal_to
    | greater_or_equal_to
    | less_than
    | greater_than
    | or
    | and
    | equals
    | different
    | nav
}

// Unary
negation = _{ "-" }
not = _{ "not" }
increment = _{ "++" }
decrement = _{ "--" }
type_of = _{"typeof"}
call = { "(" ~ expression_list? ~ ")" }
indexing = { "[" ~ expression_list? ~ "]" }

prefix_operator = {
    decrement
    | negation
    | increment
    | not
    | type_of
}

postfix_operator = {
    decrement
    | increment
    | call
    | indexing
}

// Identifier

identifier = @{
    !("not" | "or" | "and" | "typeof" | "true" | "false" | "let" | "mut") ~
    (ASCII_ALPHA | "_") ~ ( ASCII_ALPHANUMERIC | "_" )*
}


// ================
// == Statements ==
// ================

// Add it to a specific rule in order to get it in the error messages when it is missing
semicolon = { ";" }

statement = { (assignment | expression) ~ semicolon }

// Assignments

// What goes to the left of the =
// An expression is too generic, a lot of matches will be invalid
// They will be handled in the semantic analysis

mutable = { "let" }
immutable = { "const" }

left_hand_side = {
    ( mutable | immutable ) ~ identifier ~ (":" ~ expression)?
    | expression
}

assignment = { left_hand_side ~ "=" ~ expression }