// Define whitespace and comment. These will be skipped.
WHITESPACE = _{ " " | "\r\n" | "\n" | "\r" }
COMMENT = _{
    ("//" ~ ( !"\n" ~ ANY)* ~ ("\n" | EOI))
    | ("/*" ~ (!"*/" ~ ANY)* ~ "*/" )
}

// == Global rule ==

file = { SOI ~ structural_element* ~ EOI }

// =================
// == Expressions ==
// =================

expression = { binary_operation }

binary_operation = { unary_operation ~ (binary_operator ~ unary_operation)* }

unary_operation = {
    (prefix_operator)? ~ term ~ (postfix_operator)?
}

term = {float | integer | bool | char | raw_string | string | identifier  | indexing | "(" ~ expression ~ ")"}


// == Literals ==

// Integers
dec_integer = @{ ASCII_DIGIT+ }
hex_integer = @{ ASCII_HEX_DIGIT+ }
bin_integer = @{ ASCII_BIN_DIGIT+ }
integer = ${ "0x" ~ hex_integer | "0b" ~ bin_integer | dec_integer }

// Floats
float = @{ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }

// Booleans
bool = { "true" | "false" }

// Char

character = @{
    // Normal character
    !("\"" | "\\") ~ ANY
    // Escape sequence
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    // Unicode escape sequence
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}

char = ${ "'" ~ character ~ "'" }

// Strings

inner_string = ${ character* }

string = ${ "\"" ~ inner_string ~ "\"" }

inner_raw_string = @{ (!("\"" ~ PEEK) ~ ANY)* }

raw_string = ${ "r" ~ PUSH("#"*) ~ "\"" ~ inner_raw_string ~  "\"" ~ POP }

// Function call

expression_list = {
    expression ~ ("," ~ expression)*
}

// == Operators ==

// Binary
plus = { "+" }
times = { "*" }
minus = { "-" }
div = { "/" }
exponent = { "**" }
modulo = { "%" }
or = { "or" }
and = { "and" }
less_or_equal_to = { "<=" }
greater_or_equal_to = { ">=" }
less_than = { "<" }
greater_than = { ">" }
equals = { "==" }
different = { "!=" }
nav = { "." }


binary_operator = _{
    exponent
    | times
    | div
    | modulo
    | plus
    | minus
    | less_or_equal_to
    | greater_or_equal_to
    | less_than
    | greater_than
    | or
    | and
    | equals
    | different
    | nav
}

// Unary
negation = _{ "-" }
not = _{ "not" }
increment = _{ "++" }
decrement = _{ "--" }
type_of = _{"typeof"}
call = { "(" ~ expression_list? ~ ")" }
indexing = { "[" ~ expression_list? ~ "]" }

prefix_operator = {
    decrement
    | negation
    | increment
    | not
    | type_of
}

postfix_operator = {
    decrement
    | increment
    | call
    | indexing
}

// Identifier

identifier = @{
    !("not" | "or" | "and" | "typeof" | "true" | "false" | "let" | "mut" | "if"
    | "else" | "for" | "while" | "in" | "module" | "fun" | "return" | "import") ~
    (ASCII_ALPHA | "_") ~ ( ASCII_ALPHANUMERIC | "_" )*
}


// ================
// == Statements ==
// ================

// Add it to a specific rule in order to get it in the error messages when it is missing
semicolon = { ";" }

statement = { (return_statement | affectation | left_hand_side) ~ semicolon | block | branch | for_loop | while_loop }

// affectations

// What goes to the left of the =
// An expression is too generic, a lot of matches will be invalid
// They will be handled in the semantic analysis

mutable = { "let" }
immutable = { "const" }

left_hand_side = {
    declaration
    | expression
}

// Declaration without prefix and with required type, used in functions
param_declaration = { identifier ~ ":" ~ expression }

// Variable declaration, with prefix, and optional type
declaration = { ( mutable | immutable ) ~ identifier ~ (":" ~ expression)? }

affectation_operator = { "=" | "+=" | "-=" | "*=" | "/=" | "%=" }

affectation = { left_hand_side ~ affectation_operator ~ expression }

// Return statement

return_statement = { "return" ~ expression }

// Block

// A block is a series of statements. Ex: the body of a loop

block = { "{" ~ statement* ~ "}" }

// Branches

branch = { "if" ~ "(" ~ expression ~ ")" ~ statement ~ ( "else" ~ statement )? }

// For loop

for_loop = { "for" ~ "(" ~ (
    affectation ~ semicolon ~ expression ~ semicolon ~  (affectation | expression)
    | declaration ~ "in" ~ expression
    ) ~ ")" ~ statement }

// While loop

while_loop = { "while" ~ "(" ~ expression ~ ")" ~ statement }

// ================
// == Structural ==
// ================

// Structural elements are the things that are neither expressions nor statements,
// but are used to structure the code in different parts.
// It includes functions, modules, and files (since files are modules)

structural_element = { import | function | module }

// == Module ==
// A module is a structural element containing other structural elements.
// For example, a module may contain other modules and some functions.
// A file is an implicit module

module = { "module" ~ identifier ~ "{" ~ structural_element* ~ "}" }

// == Function ==
// A function is ... well I hope that you know

function_def_parameters = { param_declaration ~ ( "," ~ param_declaration)* }

function = { "fun" ~ identifier ~ "(" ~ function_def_parameters? ~ ")" ~ ( "->" ~ expression )? ~ block }

// == Import ==
// A import is a structural element that references a file or a specific content of a file.
// It can be used to link multiple files together.

import = { "import" ~ expression ~ semicolon }